/*
 *	digest-sse.c
 *
 *	(c) 2020 Stuart Hunter
 *
 *  *** GENERATED BY FLEX - DO NOT EDIT .c FILE ***
 *  *** GENERATED BY FLEX - DO NOT EDIT .c FILE ***
 *  *** GENERATED BY FLEX - DO NOT EDIT .c FILE ***
 *
 *	TODO:
 *
 *	This program is free software: you can redistribute it and/or modify
 *	it under the terms of the GNU General Public License as published by
 *	the Free Software Foundation, either version 3 of the License, or
 *	(at your option) any later version.
 *
 *	This program is distributed in the hope that it will be useful,
 *	but WITHOUT ANY WARRANTY; without even the implied warranty of
 *	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *	GNU General Public License for more details.
 *
 *	See <http://www.gnu.org/licenses/> to get a copy of the GNU General
 *	Public License.
 *
 */

%option always-interactive

%{

#include <stdio.h>
#include <stdlib.h>
#include "visualize.h"
#include "vizsse.h"

#ifndef NDEBUG
#define YYDEBUG 1
#endif

static char* type_buf = 0;
static const char* type = 0;

static char* data_buf = 0;
static const char* data = 0;

static char* reply_url = 0;

static void set_reply_url(const char* url) {
  free(reply_url);
  reply_url = url ? strdup(url) : 0;
}

static void data_add(const char* string)
{
  size_t new_len = (data_buf ? strlen(data_buf) : 0) + strlen(string) + 1;

  data_buf = (char*)realloc(data_buf, new_len + 1);
  strcat(data_buf, "\n");
  strcat(data_buf, string);
  
  data = data_buf;
}

static void data_reset()
{
  if(data_buf)
    *data_buf = 0;

  data = NULL;
}

static void type_add(const char* string)
{
  size_t new_len = (type_buf ? strlen(type_buf) : 0) + strlen(string) + 1;

  type_buf = (char*)realloc(type_buf, new_len + 1);
  strcat(type_buf, "\n");
  strcat(type_buf, string);
  
  type = type_buf;
}

static void type_reset()
{
  if(type_buf)
    *type_buf = 0;

  type = NULL;
}

static char* headers[MAX_HEADERS] = { 0 };
static char** header_ptr = headers;

static void headers_reset() {
  char** ph = headers;
  while(*ph) {
    free(*ph);
    *ph++ = 0;
  }
  
  header_ptr = headers;
}

static void header_add(const char* s) {
  if(header_ptr - headers < MAX_HEADERS - 1) {
    *header_ptr++ = strdup(s);
    *header_ptr = NULL;
  }
}

static void header_add_from_line(char* line)
{
  char* colon = strchr(line, ':');
  if(!colon || colon == line) return;
  
  *colon = '=';

  /* upcase all chars until colon */
  {
    char* s;
    for(s = line; s < colon; ++s) {
      *s = toupper(*s);
    }
  }
  
  if(isspace(colon[1])) {
    memmove(line+1, line, colon - line);
    colon[1] = '=';
    line += 1;
  }

  header_add(line);
}

static void flush()
{

  /* If neither headers nor data are set, then we flush after some
  // keep-alive traffic (or some other traffic that does not conform
  // to SSE)
  */

  if(data && *data) {
    on_sse_event(data ? data : "");
  }

  set_reply_url(0);
  data_reset();
  type_reset();
  headers_reset();

}

%}

%%

                  /* the data attribute is special: multiple lines are concatenated */
data:\ .*         data_add(yytext + 6);
data:.*           data_add(yytext + 5);

                  /* the type attribute is special: multiple lines are concatenated
                     non-standard - we may have added to describe the payload (SA/VU)
                  */
type:\ .*         type_add(yytext + 6);
type:.*           type_add(yytext + 5);

                  /* the data attribute is special: multiple lines are concatenated */
reply:\ .*        set_reply_url(yytext + 7);
reply:.*          set_reply_url(yytext + 6);

                  /* all other attributes should appear only once */

[-_0-9a-z]+:\ .*  header_add_from_line(yytext);
[-_0-9a-z]+:.*    header_add_from_line(yytext);

                  /* ignore lines starting with a colon */
:.*               ;

                  /* ignore lines without colon ***IN VIOLATION WITH THE SPECS*** */
.+                ;

\n\n              flush();
\n                /* we're not flushing yet - this is within an event */

%%

/* thin/or curl callback to feed some data into the lexer. */
void parse_payload(char *data, uint64_t len) {
  (void)yyunput;
  
  YY_BUFFER_STATE buffer = yy_scan_bytes(data, (size_t)len);
  while(yylex());
  yy_delete_buffer(buffer);
}

int yywrap() { 
  return 1; 
}

